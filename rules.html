<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Snake - 게임 설명</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
</head>
<body>
<header class="site-header">
  <div class="logo"><a href="index.html">SNAKE</a></div>
  <nav class="site-nav">
    <a href="index.html">홈</a>
    <a href="game.html">게임</a>
    <a href="rules.html" class="current">게임 설명</a>
    <a href="achievements.html">업적</a>
    <a href="ranking.html">랭킹</a>
  </nav>
</header>

<main class="site-main">
  <div class="layout-container layout-rules">
    <!-- 왼쪽 메뉴 -->
    <aside class="rules-menu">
      <h2>설명 목록</h2>
      <ul>
        <li><button type="button" class="rule-link active" data-target="rule-basic">게임 공통 규칙</button></li>
        <li><button type="button" class="rule-link" data-target="rule-classic">클래식 모드</button></li>
        <li><button type="button" class="rule-link" data-target="rule-expert">익스퍼트 모드 + 아이템/위험요소</button></li>
      </ul>
    </aside>

    <!-- 오른쪽 내용 -->
    <section class="rules-content">

      <!-- 공통 규칙 -->
      <article id="rule-basic" class="rule-section active">
        <h2>게임 공통 규칙</h2>
        <p>Snake Web Game은 방향키로 뱀을 조작하여 사과를 먹으며 점수를 올리는 게임입니다.</p>
        <ul class="rule-list">
          <li>조작 키: 상/하/좌/우 방향키</li>
          <li>일시정지 / 재개: <strong>ESC</strong> 키</li>
          <li>벽 또는 자신의 몸과 부딪히면 게임 오버</li>
          <li>사과를 먹으면 점수 +1, 뱀 길이 +1</li>
          <li>게임 시작은 <strong>Start 버튼</strong> 또는 방향키 입력으로 가능합니다.</li>
        </ul>
      </article>

      <!-- 클래식 모드 -->
      <article id="rule-classic" class="rule-section">
        <h2>클래식 모드</h2>
        <p>클래식 모드는 가장 기본적인 스네이크 모드입니다.</p>
        <ul class="rule-list">
          <li>맵에는 <strong>장애물, 아이템, 속도 이벤트가 등장하지 않습니다.</strong></li>
          <li>난이도(easy / normal / hard)는 <strong>게임 속도에 영향을 주지 않습니다.</strong> (단, 화면 정보 표시용으로 선택 가능합니다.)</li>
          <li>벽과 자신의 몸에 부딪히면 즉시 게임 오버입니다.</li>
          <li>ESC로 일시정지/재개가 가능하며, 일시정지 시 화면 중앙에 “PAUSED” 오버레이가 표시됩니다.</li>
        </ul>
      </article>

      <!-- 익스퍼트 모드 + 아이템 / 위험요소 -->
      <article id="rule-expert" class="rule-section">
        <h2>익스퍼트 모드</h2>
        <p>익스퍼트 모드는 장애물, 추적지뢰, 다양한 아이템과 속도 이벤트가 섞여 있는 고난이도 모드입니다.</p>

        <h3>익스퍼트 기본 규칙</h3>
        <ul class="rule-list">
          <li>사과를 일정 개수 먹을 때마다 <strong>위험요소 + 아이템</strong> 이벤트가 발생합니다.</li>
          <li>사과를 먹기 직전에 화면 상단에 <strong>WARNING!</strong> 메시지와 함께 다음에 등장할 위험요소가 표시됩니다.</li>
          <li>사과를 먹었을 때:
            <ul>
              <li>장애물 / 추적지뢰 / 속도 이벤트 중 하나가 적용되고,</li>
              <li>폭탄 / 특수 폭탄 / 길이 축소 / 텔레포트 / 차원이동 중 하나의 아이템이 등장합니다.</li>
            </ul>
          </li>
        </ul>

        <!-- 필터 + 아이템/위험요소 카드 -->
        <section class="rule-items">
          <h3>아이템 / 위험요소 목록</h3>

          <div class="rule-item-filter">
            <button type="button" class="filter-btn active" data-filter="all">전체</button>
            <button type="button" class="filter-btn" data-filter="item">아이템만</button>
            <button type="button" class="filter-btn" data-filter="hazard">위험요소만</button>
          </div>

          <div class="rule-item-grid">
            <!-- 사과 (기본 점수 아이템) -->
            <div class="rule-item-card" data-type="item" data-key="apple">
              <canvas class="icon-canvas" width="48" height="48" data-icon="apple"></canvas>
              <div class="rule-item-name">사과</div>
              <div class="rule-item-short">기본 점수 +1, 길이 +1</div>
            </div>

            <!-- 폭탄 -->
            <div class="rule-item-card" data-type="item" data-key="bomb">
              <canvas class="icon-canvas" width="48" height="48" data-icon="bomb"></canvas>
              <div class="rule-item-name">폭탄</div>
              <div class="rule-item-short">일정 영역의 장애물을 제거</div>
            </div>

            <!-- 특수 폭탄 -->
            <div class="rule-item-card" data-type="item" data-key="superbomb">
              <canvas class="icon-canvas" width="48" height="48" data-icon="superbomb"></canvas>
              <div class="rule-item-name">특수 폭탄</div>
              <div class="rule-item-short">서로 붙어있는 장애물 덩어리를 한 번에 제거</div>
            </div>

            <!-- 길이 축소 -->
            <div class="rule-item-card" data-type="item" data-key="shrink">
              <canvas class="icon-canvas" width="48" height="48" data-icon="shrink"></canvas>
              <div class="rule-item-name">길이 축소</div>
              <div class="rule-item-short">뱀의 길이를 1칸 줄여서 회피 공간 확보</div>
            </div>

            <!-- 텔레포트 -->
            <div class="rule-item-card" data-type="item" data-key="teleport">
              <canvas class="icon-canvas" width="48" height="48" data-icon="teleport"></canvas>
              <div class="rule-item-name">텔레포트</div>
              <div class="rule-item-short">한 번만 벽을 통과해 반대편으로 이동</div>
            </div>

            <!-- 차원이동 -->
            <div class="rule-item-card" data-type="item" data-key="phase">
              <canvas class="icon-canvas" width="48" height="48" data-icon="phase"></canvas>
              <div class="rule-item-name">차원이동</div>
              <div class="rule-item-short">일정 시간 장애물/아이템/사과 무시, 출구 도달 시 복귀</div>
            </div>

            <!-- 장애물 -->
            <div class="rule-item-card" data-type="hazard" data-key="obstacle">
              <canvas class="icon-canvas" width="48" height="48" data-icon="obstacle"></canvas>
              <div class="rule-item-name">장애물</div>
              <div class="rule-item-short">부딪히면 게임 오버, 폭탄으로 제거 가능</div>
            </div>

            <!-- 추적지뢰 -->
            <div class="rule-item-card" data-type="hazard" data-key="mine">
              <canvas class="icon-canvas" width="48" height="48" data-icon="mine"></canvas>
              <div class="rule-item-name">추적지뢰</div>
              <div class="rule-item-short">주기적으로 뱀의 머리 방향으로 한 칸씩 이동, 닿으면 게임 오버</div>
            </div>

            <!-- 속도 이벤트(아이콘 없이 텍스트만) -->
            <div class="rule-item-card" data-type="hazard" data-key="speed">
              <div class="rule-item-text-only">
                <div class="rule-item-name">속도 변화 이벤트</div>
                <div class="rule-item-short">게임 속도가 일정 비율로 빨라지거나 느려짐</div>
              </div>
            </div>
          </div>

          <!-- 상세 설명 영역 -->
          <div class="rule-item-detail">
            <h4 id="detail-title">아이템 / 위험요소 설명</h4>
            <p id="detail-text">카드를 클릭하면 자세한 설명이 표시됩니다.</p>
          </div>

        </section>
      </article>

    </section>
  </div>
</main>

<footer class="site-footer">
  <p>© 2025 Snake Web Game</p>
</footer>

<script>
  // ============================
  // 좌측 메뉴: 섹션 전환
  // ============================
  $(function() {
    $(".rule-link").on("click", function () {
      const target = $(this).data("target");

      $(".rule-link").removeClass("active");
      $(this).addClass("active");

      $(".rule-section").removeClass("active");
      $("#" + target).addClass("active");
    });
  });

  // ============================
  // 아이템 / 위험요소 상세 내용 데이터
  // ============================
  const ruleDetailData = {
    apple: {
      title: "사과",
      text: "사과를 먹으면 점수가 1점 오르고, 뱀의 길이가 1칸 늘어납니다. 모든 모드에서 기본이 되는 아이템입니다."
    },
    bomb: {
      title: "폭탄",
      text: "폭탄을 먹으면 일정 영역에 배치된 장애물을 제거합니다. 폭탄 중심을 기준으로 정해진 패턴 내의 장애물이 사라집니다."
    },
    superbomb: {
      title: "특수 폭탄",
      text: "특수 폭탄은 서로 붙어 있는 하나의 장애물 덩어리를 통째로 제거합니다. 장애물이 많이 쌓였을 때 매우 강력합니다."
    },
    shrink: {
      title: "길이 축소",
      text: "뱀의 꼬리가 1칸 줄어듭니다. 몸이 길어져서 회피가 어려울 때 일부러 사용하는 전략용 아이템입니다."
    },
    teleport: {
      title: "텔레포트",
      text: "일정 방향(좌우 또는 상하)의 벽을 한 번만 통과할 수 있습니다. 통과 후에는 반대편 벽으로 이어서 등장하며, 효과는 1회 사용 후 종료됩니다."
    },
    phase: {
      title: "차원이동",
      text: "차원이동 상태에서는 장애물, 사과, 아이템에 부딪혀도 무시되며 맵을 자유롭게 이동할 수 있습니다. 지정된 출구 지점에 도달하면 차원이동 상태가 해제됩니다."
    },
    obstacle: {
      title: "장애물",
      text: "장애물에 닿으면 즉시 게임 오버입니다. 폭탄/특수 폭탄으로 제거할 수 있으며, 장애물 패턴은 사전에 미리 표시되는 경우도 있습니다."
    },
    mine: {
      title: "추적지뢰",
      text: "추적지뢰는 주기적으로 뱀의 머리 방향으로 한 칸씩 이동합니다. 지뢰에 닿으면 게임 오버가 되며, 다음 사과를 먹을 때까지 맵 위를 돌아다닙니다."
    },
    speed: {
      title: "속도 변화 이벤트",
      text: "속도 이벤트가 발생하면 게임 속도가 일정 비율로 빨라지거나 느려집니다. 사전에 WARNING 메시지로 어느 방향(가속/감속)으로 변화할지 알려줍니다."
    }
  };

  // ============================
  // jQuery 필터링 + 상세 설명 클릭
  // ============================
  $(function() {
    // 필터 버튼
    $(".filter-btn").on("click", function() {
      const filter = $(this).data("filter");
      $(".filter-btn").removeClass("active");
      $(this).addClass("active");

      $(".rule-item-card").each(function() {
        const type = $(this).data("type");
        if (filter === "all" || type === filter) {
          $(this).stop(true, true).fadeIn(150);
        } else {
          $(this).stop(true, true).fadeOut(150);
        }
      });
    });

    // 카드 클릭 시 상세 정보 표시
    $(".rule-item-card").on("click", function() {
      const key = $(this).data("key");
      const data = ruleDetailData[key];
      if (!data) return;

      $("#detail-title").text(data.title);
      $("#detail-text").text(data.text);

      $(".rule-item-card").removeClass("selected");
      $(this).addClass("selected");
    });
  });

  // ============================
  // 캔버스 아이콘 그리기
  // (인게임 expert_script의 스타일을 참고한 축소 버전)
  // ============================
  function drawAppleIcon(ctx, size) {
    const cx = size / 2;
    const cy = size / 2;
    const r = size * 0.4;

    ctx.clearRect(0, 0, size, size);

    ctx.fillStyle = "#e53935";
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#b71c1c";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = "#2e7d32";
    ctx.beginPath();
    ctx.ellipse(cx + r * 0.2, cy - r * 0.7, r * 0.4, r * 0.2, -0.5, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawBombIcon(ctx, size, isSuper) {
    const cx = size / 2;
    const cy = size / 2;
    const r = size * 0.35;

    ctx.clearRect(0, 0, size, size);

    ctx.fillStyle = "#9e9e9e";
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#616161";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();

    // 심지
    ctx.strokeStyle = "#5d4037";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx + r * 0.3, cy - r * 0.7);
    ctx.lineTo(cx + r * 0.6, cy - r * 1.2);
    ctx.stroke();

    if (isSuper) {
      ctx.strokeStyle = "#ffeb3b";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  function drawShrinkIcon(ctx, size) {
    ctx.clearRect(0, 0, size, size);

    ctx.fillStyle = "#44aa44";
    ctx.fillRect(size * 0.15, size * 0.2, size * 0.7, size * 0.6);

    ctx.fillStyle = "#ffffff";
    ctx.font = Math.floor(size * 0.5) + "px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("-1", size / 2, size / 2 + 1);
  }

  function drawTeleportIcon(ctx, size) {
    const cx = size / 2;
    const cy = size / 2;
    const rx = size * 0.35;
    const ry = size * 0.22;

    ctx.clearRect(0, 0, size, size);

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(Math.PI / 4);

    ctx.lineWidth = size * 0.2;

    ctx.strokeStyle = "#1976d2";
    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, Math.PI / 2, 3 * Math.PI / 2, false);
    ctx.stroke();

    ctx.strokeStyle = "#ff9800";
    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, -Math.PI / 2, Math.PI / 2, false);
    ctx.stroke();

    ctx.restore();
  }

  function drawPhaseIcon(ctx, size, inverted) {
    const cx = size / 2;
    const cy = size / 2;
    const rOuter = size * 0.42;

    ctx.clearRect(0, 0, size, size);

    const baseColor = inverted ? "#ffffff" : "#9c27b0";
    const swirlColor = inverted ? "#9c27b0" : "#ffffff";

    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = swirlColor;
    ctx.lineWidth = 2;

    const turns = 3;
    for (let i = 0; i < turns; i++) {
      const t0 = i * 0.9;
      const t1 = t0 + Math.PI * 0.9;
      const rMid = rOuter * (0.25 + 0.15 * i);
      ctx.beginPath();
      for (let t = t0; t <= t1; t += 0.1) {
        const rr = rMid + (t - t0) * 0.15;
        const xPos = cx + Math.cos(t) * rr;
        const yPos = cy + Math.sin(t) * rr;
        if (t === t0) ctx.moveTo(xPos, yPos);
        else ctx.lineTo(xPos, yPos);
      }
      ctx.stroke();
    }
  }

  function drawObstacleIcon(ctx, size) {
    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = "#8b1a1a";
    ctx.fillRect(size * 0.15, size * 0.15, size * 0.7, size * 0.7);
  }

  function drawMineIcon(ctx, size) {
    ctx.clearRect(0, 0, size, size);
    ctx.fillStyle = "#000000";
    ctx.fillRect(size * 0.15, size * 0.15, size * 0.7, size * 0.7);

    ctx.fillStyle = "#ff3333";
    ctx.font = Math.floor(size * 0.6) + "px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("!", size / 2, size / 2 + 2);
  }

  // ============================
  // DOM 로드 후 캔버스에 아이콘 그리기
  // ============================
  $(function() {
    $(".icon-canvas").each(function() {
      const canvas = this;
      const icon = canvas.dataset.icon;
      const ctx = canvas.getContext("2d");
      const size = canvas.width;

      if (icon === "apple")       drawAppleIcon(ctx, size);
      else if (icon === "bomb")   drawBombIcon(ctx, size, false);
      else if (icon === "superbomb") drawBombIcon(ctx, size, true);
      else if (icon === "shrink") drawShrinkIcon(ctx, size);
      else if (icon === "teleport") drawTeleportIcon(ctx, size);
      else if (icon === "phase")  drawPhaseIcon(ctx, size, false);
      else if (icon === "obstacle") drawObstacleIcon(ctx, size);
      else if (icon === "mine")   drawMineIcon(ctx, size);
    });
  });
</script>
</body>
</html>
